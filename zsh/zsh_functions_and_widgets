# kill all containers and prune all images
dockerclean() {
        if ! command -v docker >/dev/null; then
                echo "docker not found"
                return 1
        fi
        docker kill $(docker ps -aq)
        yes | docker system prune --all
}

# remove all images matching the patterns
dockerrmi() {
        if ! command -v docker >/dev/null; then
                echo "docker not found"
                return 1
        fi

        if (($# == 0)); then
                echo "Usage: dockerrmi <pattern1> <pattern2> or dockerrmi <pattern1,pattern2,...>"
                echo "Patterns are case-insensitive and matched against the full image name."
                return 1
        fi

        local patterns_array=()
        for arg in "$@"; do
                patterns_array+=("${arg//,/|}")
        done

        local final_pattern
        IFS='|' final_pattern="${patterns_array[*]}"

        docker images | awk -v pattern="$final_pattern" '
        BEGIN { IGNORECASE = 1 }
        $1 ~ pattern || $2 ~ pattern { print $3 }
        ' | xargs -r docker rmi -f
}

# kill all processes matching the patterns
pskill() {
        if (($# == 0)); then
                echo "Usage: pskill <pattern1> <pattern2> or pskill <pattern1,pattern2,...>"
                echo "Patterns are case-insensitive and matched against the full command line."
                return 1
        fi

        local patterns_array=()
        for arg in "$@"; do
                patterns_array+=("${arg//,/|}")
        done

        local final_pattern
        IFS='|' final_pattern="${patterns_array[*]}"

        ps aux | awk -v pat="$final_pattern" '
        BEGIN { IGNORECASE = 1 }
        $11 ~ pat { print $2 }
        ' | xargs -r sudo kill -9
}

killports() {
        if (($# == 0)); then
                echo "Usage: killports <pattern1> <pattern2> or killports <pattern1,pattern2,...>"
                echo "Patterns are case-insensitive and matched against the full image name."
                return 1
        fi
        local ports=$(
                IFS=,
                echo "$*"
        )
        echo "Killing ports $ports"
        sudo kill -9 $(sudo lsof -ti :$ports)
}

# fuzzy search and checkout git local/remote branches
gb() {
        force=$1
        selected=$(git branch -va | fzf-tmux | awk '{print $1}')
        if [[ -z "$selected" ]]; then
                echo "No branch selected."
                return 1
        fi

        if [[ $force != "-f" && $force != "--force" ]]; then
                force=""
        fi

        if [[ $selected == remotes/* ]]; then
                remote_branch=${selected#remotes/}
                local_branch=${remote_branch#*/}

                if git show-ref --verify --quiet "refs/heads/$local_branch"; then
                        echo "Local branch '$local_branch' already exists. Switching..."
                        git checkout $force "$local_branch"
                else
                        echo "Tracking remote branch '$remote_branch' as '$local_branch'..."
                        git checkout -t $force "$remote_branch"
                fi
        else
                echo "Checking out local branch '$selected'..."
                git checkout $force "$selected"
        fi
}

# create and switch to a new tmux session from the current directory
# works inside tmux sessions
tns() {
        local session_name="$1"
        [ -z "$session_name" ] && {
                echo "Usage: tns <session_name>"
                        return 1
                }

        if [ -z "$TMUX" ]; then
                tmux new -s "$session_name"
                return 1
        fi

        if ! tmux has-session -t "$session_name" 2>/dev/null; then
                tmux new-session -d -s "$session_name" -c "$PWD"
        fi
        tmux switch-client -t "$session_name"
}

# fuzzy search and paste path to dir
fzf-dir-widget() {
        if ! command -v fd >/dev/null; then
                echo "fd not found"
                return 1
        fi

        if ! command -v fzf >/dev/null; then
                echo "fzf not found"
                return 1
        fi

        local dir
        dir=$(fd --type d --hidden --exclude .git | fzf -- --preview 'ls -l {}' --preview-window=right:40%) || return
        LBUFFER+="$dir"
        zle reset-prompt
}
zle -N fzf-dir-widget
bindkey -a '\ed' fzf-dir-widget
bindkey '\ed' fzf-dir-widget

# search for a string in all files in the current directory
exactgrep() {
        if ! command -v rg >/dev/null; then
                echo "ripgrep not found"
                return 1
        fi

        if ! command -v fzf >/dev/null; then
                echo "fzf not found"
                return 1
        fi

        RG_PREFIX="rg --hidden --column --line-number --no-heading --color=always --smart-case "
        INITIAL_QUERY="${*:-}"
        fzf --ansi --disabled --query "$INITIAL_QUERY" \
                --bind "start:reload:$RG_PREFIX {q}" \
                --bind "change:reload:sleep 0.1; $RG_PREFIX {q} || true" \
                --delimiter : \
                --preview 'filename={1}; lineno={2}; start=$(( lineno > 10 ? lineno - 10 : 1 )); end=$(( lineno + 10 )); bat --color=always --highlight-line "$lineno" --line-range "${start}:${end}" "$filename"' \
                --preview-window 'right:50%' \
                --bind 'ctrl-y,enter:become(nvim {1} +{2})'
        }

zle -N exactgrep
bindkey -a '\eg' exactgrep
bindkey '\eg' exactgrep

# fuzzy search for a string in all files in the current directory
# WARNING: might eat up all your memory
fuzzygrep() {
        if ! command -v rg >/dev/null; then
                echo "ripgrep not found"
                return 1
        fi

        if ! command -v fzf >/dev/null; then
                echo "fzf not found"
                return 1
        fi

        local dir="${1:-.}"
        local source_cmd

        if command -v rg >/dev/null 2>&1; then
                source_cmd="rg --hidden --column --line-number --color=always --no-heading \"\" \"$dir\""
        else
                source_cmd="grep --color=always --line-number --recursive --exclude-dir={.git,.idea,node_modules,venv} \"\" \"$dir\""
        fi

        eval "$source_cmd" | fzf --multi --ansi --delimiter : \
                --preview 'filename={1}; lineno={2}; start=$(( lineno > 10 ? lineno - 10 : 1 )); end=$(( lineno + 10 )); bat --color=always --highlight-line "$lineno" --line-range "${start}:${end}" "$filename"' \
                --preview-window right:50% \
                --bind 'ctrl-y,enter:become(nvim {1} +{2})'
}

zle -N fuzzygrep
bindkey -a '^G' fuzzygrep
bindkey '^G' fuzzygrep

bindkey -M viins '^N' fzf-tab-complete
bindkey -M viins '^P' fzf-tab-complete

# stop word deletion at word boundaries
function backward-kill-word-strict() {
        local wordchars="$WORDCHARS"
        local i=${#LBUFFER}
                local first=true
                local delete_space=false
                while ((i > 0)); do
                        local c="${LBUFFER[i]}"
                        if [[ "$c" == " " ]]; then
                                if [[ "$first" == true ]]; then
                                        delete_space=true
                                elif [[ "$delete_space" != true ]]; then
                                        break
                                fi
                        else
                                if [[ "$delete_space" == true ]]; then
                                        break
                                fi
                                delete_space=false
                        fi

                        if [[ "$first" == true || "$wordchars" != *"$c"* || (("$delete_space" == true && "$c" == " ")) ]]; then
                                ((i--))
                        else
                                break
                        fi
                        first=false
                done
                LBUFFER="${LBUFFER[1, i]}"
        }

zle -N backward-kill-word-strict
bindkey '^W' backward-kill-word-strict

# control-z to or suspend/resume current job
fg_or_suspend() {
        if jobs % 2>/dev/null | grep -iq 'suspended'; then
                fg
                zle reset-prompt
        else
                zle send-break
        fi
}

zle -N fg_or_suspend
bindkey '^Z' fg_or_suspend

# https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/extract/extract.plugin.zsh
extract() {
        setopt localoptions noautopushd

        if (( $# == 0 )); then
          cat >&2 <<'EOF'
Usage: extract [-option] [file ...]

Options:
    -r, --remove    Remove archive after unpacking.
EOF
        fi

  local remove_archive=1
  if [[ "$1" == "-r" ]] || [[ "$1" == "--remove" ]]; then
          remove_archive=0
          shift
  fi

  local pwd="$PWD"
  while (( $# > 0 )); do
          if [[ ! -f "$1" ]]; then
                  echo "extract: '$1' is not a valid file" >&2
                  shift
                  continue
          fi

          local success=0
          local file="$1" full_path="${1:A}"
          local extract_dir="${1:t:r}"

          # Remove the .tar extension if the file name is .tar.*
          if [[ $extract_dir =~ '\.tar$' ]]; then
                  extract_dir="${extract_dir:r}"
          fi

          # If there's a file or directory with the same name as the archive
          # add a random string to the end of the extract directory
          if [[ -e "$extract_dir" ]]; then
                  local rnd="${(L)"${$(( [##36]$RANDOM*$RANDOM ))}":1:5}"
                  extract_dir="${extract_dir}-${rnd}"
          fi

          # Create an extraction directory based on the file name
          command mkdir -p "$extract_dir"
          builtin cd -q "$extract_dir"
          echo "extract: extracting to $extract_dir" >&2

          case "${file:l}" in
                  (*.tar.gz|*.tgz)
                          (( $+commands[pigz] )) && { tar -I pigz -xvf "$full_path" } || tar zxvf "$full_path" ;;
                          (*.tar.bz2|*.tbz|*.tbz2)
                                  (( $+commands[pbzip2] )) && { tar -I pbzip2 -xvf "$full_path" } || tar xvjf "$full_path" ;;
                                  (*.tar.xz|*.txz)
                                          (( $+commands[pixz] )) && { tar -I pixz -xvf "$full_path" } || {
                                                  tar --xz --help &> /dev/null \
                                                  && tar --xz -xvf "$full_path" \
                                                  || xzcat "$full_path" | tar xvf - } ;;
                                  (*.tar.zma|*.tlz)
                                          tar --lzma --help &> /dev/null \
                                                  && tar --lzma -xvf "$full_path" \
                                                  || lzcat "$full_path" | tar xvf - ;;
                                  (*.tar.zst|*.tzst)
                                          tar --zstd --help &> /dev/null \
                                                  && tar --zstd -xvf "$full_path" \
                                                  || zstdcat "$full_path" | tar xvf - ;;
                                  (*.tar) tar xvf "$full_path" ;;
                                  (*.tar.lz) (( $+commands[lzip] )) && tar xvf "$full_path" ;;
                                  (*.tar.lz4) lz4 -c -d "$full_path" | tar xvf - ;;
                                  (*.tar.lrz) (( $+commands[lrzuntar] )) && lrzuntar "$full_path" ;;
                                  (*.gz) (( $+commands[pigz] )) && pigz -cdk "$full_path" > "${file:t:r}" || gunzip -ck "$full_path" > "${file:t:r}" ;;
                                  (*.bz2) (( $+commands[pbzip2] )) && pbzip2 -d "$full_path" || bunzip2 "$full_path" ;;
                                  (*.xz) unxz "$full_path" ;;
                                  (*.lrz) (( $+commands[lrunzip] )) && lrunzip "$full_path" ;;
                                  (*.lz4) lz4 -d "$full_path" ;;
                                  (*.lzma) unlzma "$full_path" ;;
                                  (*.z) uncompress "$full_path" ;;
                                  (*.zip|*.war|*.jar|*.ear|*.sublime-package|*.ipa|*.ipsw|*.xpi|*.apk|*.aar|*.whl|*.vsix|*.crx) unzip "$full_path" ;;
                                  (*.rar) unrar x -ad "$full_path" ;;
                                  (*.rpm)
                                          rpm2cpio "$full_path" | cpio --quiet -id ;;
                                  (*.7z | *.7z.[0-9]*) 7za x "$full_path" ;;
                                  (*.deb)
                                          command mkdir -p "control" "data"
                                          ar vx "$full_path" > /dev/null
                                          builtin cd -q control; extract ../control.tar.*
                                          builtin cd -q ../data; extract ../data.tar.*
                                          builtin cd -q ..; command rm *.tar.* debian-binary ;;
                                  (*.zst) unzstd --stdout "$full_path" > "${file:t:r}" ;;
                                  (*.cab|*.exe) cabextract "$full_path" ;;
                                  (*.cpio|*.obscpio) cpio -idmvF "$full_path" ;;
                                  (*.zpaq) zpaq x "$full_path" ;;
                                  (*.zlib) zlib-flate -uncompress < "$full_path" > "${file:r}" ;;
                                  (*)
                                          echo "extract: '$file' cannot be extracted" >&2
                                          success=1 ;;
                          esac

                          (( success = success > 0 ? success : $? ))
                          (( success == 0 && remove_archive == 0 )) && command rm "$full_path"
                          shift

                          # Go back to original working directory
                          builtin cd -q "$pwd"

                          # If content of extract dir is a single directory, move its contents up
                          # Glob flags:
                          # - D: include files starting with .
                          # - N: no error if directory is empty
                          # - Y2: at most give 2 files
                          local -a content
                          content=("${extract_dir}"/*(DNY2))
                          if [[ ${#content} -eq 1 && -e "${content[1]}" ]]; then
                                  # The extracted file/folder (${content[1]}) may have the same name as $extract_dir
                                  # If so, we need to rename it to avoid conflicts in a 3-step process
                                  #
                                  # 1. Move and rename the extracted file/folder to a temporary random name
                                  # 2. Delete the empty folder
                                  # 3. Rename the extracted file/folder to the original name
                                  if [[ "${content[1]:t}" == "$extract_dir" ]]; then
                                          # =(:) gives /tmp/zsh<random>, with :t it gives zsh<random>
                                          local tmp_name==(:); tmp_name="${tmp_name:t}"
                                          command mv "${content[1]}" "$tmp_name" \
                                                  && command rmdir "$extract_dir" \
                                                  && command mv "$tmp_name" "$extract_dir"
                                          # Otherwise, if the extracted folder name already exists in the current
                                          # directory (because of a previous file / folder), keep the extract_dir
                                  elif [[ ! -e "${content[1]:t}" ]]; then
                                          command mv "${content[1]}" . \
                                                  && command rmdir "$extract_dir"
                                  fi
                          elif [[ ${#content} -eq 0 ]]; then
                                  command rmdir "$extract_dir"
                          fi
                  done
          }

alias x=extract
